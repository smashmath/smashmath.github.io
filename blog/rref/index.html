<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Why do we row reduce? What IS a matrix? | smashmath</title> <meta name="author" content=" "> <meta name="description" content="What does the RREF tell us, and why do we so much time on it? Why do we define matrix multiplication the way we do? My absolute most aggresive post of all time."> <meta name="keywords" content="math, blog"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%98%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://smashmath.github.io/blog/rref/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Why do we row reduce? What IS a matrix?",
      "description": "What does the RREF tell us, and why do we so much time on it? Why do we define matrix multiplication the way we do? My absolute most aggresive post of all time.",
      "published": "July 27, 2024",
      "authors": [
        {
          "author": "Taylor F.",
          "authorURL": "",
          "affiliations": [
            {
              "name": "None",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">smashmath</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Why do we row reduce? What IS a matrix?</h1> <p>What does the RREF tell us, and why do we so much time on it? Why do we define matrix multiplication the way we do? My absolute most aggresive post of all time.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#image-terminology">Image Terminology</a></div> <div><a href="#what-is-a-matrix">What IS a matrix</a></div> <ul> <li><a href="#linear-transformations">Linear Transformations</a></li> </ul> <div><a href="#representing-a-linear-transformation">Representing a linear transformation</a></div> <ul> <li><a href="#basis">Basis</a></li> <li><a href="#span-and-generating-sets">Span and generating sets</a></li> <li><a href="#linear-independence">Linear independence</a></li> <li><a href="#all-together-now">All together now</a></li> <li><a href="#change-of-basis">Change of basis</a></li> </ul> <div><a href="#column-perspective">Column Perspective</a></div> <ul> <li><a href="#a-remark-on-column-space">A remark on column space</a></li> </ul> <div><a href="#column-relationships">Column relationships</a></div> <div><a href="#row-reduction">Row reduction</a></div> <ul> <li><a href="#row-space">Row space</a></li> <li><a href="#row-space-basis">Row space basis</a></li> <li><a href="#solving-systems-of-equations">Solving systems of equations</a></li> </ul> <div><a href="#kernel-determines-rref">Kernel determines RREF</a></div> </nav> </d-contents> <p>(This is a first draft, subject to change.)</p> <p>I’ve stood by and let this go on for too long. As someone who has been tutoring/teaching linear algebra for five years now, I’ve looked at the subject as a whole through multiple different perspectives. We have this abstract difficult subject with a million terms and concepts (many terms actually being the SAME concept under a different name), problems that can look entirely different but end up asking the exact same question, AND most students have to figure it out while they are learning how to properly do a mathematical proof for the first time (which is NOT an easy skill to learn). No wonder people struggle with it! And, so, I can understand why many professors choose to offload the concepts and underlying “algebra” until later in the course, and start off with “Here’s a system of equations, row reduce it!” for three weeks. And though tedious, and generally unmotivated, it’s certainly… easy?</p> <p>The problem is that with so much to cover, my experience with most students is that the key concepts that tie EVERYTHING together are not being emphasized. So when the more important topics like basis, linear independence, span, coordinate vectors, kernel, image, etc. are introduced, the pathways between the new topic and what the student has already learned aren’t being drawn, and it all seems so disconnected. More like you’re learning something completely different solved with a similar method, rather than learning an extension of a previous concept.</p> <p>So that’s what I want to do today. I’m going to start from square one, and we’re going to change how we view row reduction, matrix multiplication, and even a matrix <em>itself</em>. And with this new perspective, I hope that everything feels more cohesive and straightforward.</p> <h3 id="image-terminology">Image Terminology</h3> <p>This post is pretty much entirely about functions, and to <em>really</em> talk about functions properly, we’re going to use the proper terminology. These are concepts you’re probably familiar with, but perhaps under different names.</p> <p>We have a function we denote \(f:X\to Y\) to mean \(f\) is a function that takes stuff in the <strong>domain</strong> \(X\) to the <strong>codomain</strong> \(Y\). i.e. <em>everything</em> in \(X\) <em>can</em> be put into the function, and every output is in \(Y\) (though we can’t necessarily reach everything in \(Y\)). For example, \(e^x\) is a function that takes in real numbers and outputs real numbers (so the \(\mathbb{R}\) is both the domain and codomain). We can put in any real number, and we’ll get out a real number. Even though every output is actually strictly positive (there’s no output for \(-1\), for example), it’s still correct to say it’s a function with codomain \(\mathbb{R}\).</p> <p>If \(f(x)=y\), then we say \(y\) is <em>the</em> <strong>image</strong> of \(x\). Images are <em>unique</em> (because a function must be “well-defined”). If you vaguely remember that a function can’t send one input to two outputs, or that it must pass the “vertical line test”, this is basically the more rigorous way to say it: the image is unique.</p> <p>It’s also very useful to say that \(f(x)=y\) means that \(x\) is <em>a</em> <strong>preimage</strong> of \(y\). Preimages are not necessarily unique. For example, with the function \(f(x)=x^2\), \(f(2)=f(-2)=4\), so \(4\) has two preimages: \(2,-2\).</p> <p>We call the complete set of all possible outputs that \(f\) can produce the <strong>image/range of \(f\)</strong>. And for special types of functions (like the ones we study in linear algebra), we call the set of all preimages of \(0\) the <strong>kernel</strong>.</p> <p>This is important to talk about up front, because understanding why matrices are useful requires understanding how the images of a few special vectors under special functions allows us to simplify how we <em>write</em> that function.</p> <h2 id="what-is-a-matrix">What IS a matrix</h2> <p>Now, some smart-asses (many of which, I love) might object to what I’m about to present and say, “a matrix is JUST an array of numbers which CAN induce a linear transformation!” And, yeah, but we’re talking in the context of linear algebra, here. In my opinion, the way to view a matrix that provides the most intuitive bang for your buck is as a <strong>Linear Transformation</strong> itself.</p> <h3 id="linear-transformations">Linear Transformations</h3> <p>First, though, I’m going to give you the completely oversimplified low-down of what the majority of abstract algebra is like, on the motivational level.</p> <blockquote> <p>“We have some things that interact in some nice way, let’s look at functions and substructures that preserve those interactions.”</p> </blockquote> <p>In terms of linear algebra, our “things” are vectors (over some field of scalars), and the interaction is vector addition and scalar multiplication.</p> <p><strong>NOTE: You can think of a “field” as just some collection of “numbers” that you can add/subtract/multiply and divide (if they’re nonzero). Just think \(\mathbb{R}\) or \(\mathbb{C}\) for the purposes of this post.</strong></p> <p>We can do these things and still get a vector, and combining these operations is called taking a “linear combination”.</p> \[v=c_1v_1+\ldots+c_nv_n\] <p>So, in a sense, we can view vector spaces as some collection of vectors, and we can take linear combinations of those vectors using scalars from the field the vector space is over.</p> <p>NOTE: Saying scalars from a “field” is important! There are other nonvector things we can use to “scale/multiply to” vectors, but being able to divide nonzero scalars is what makes linear algebra so nice (and what makes Modules–vector spaces over a ring instead of a field–much crazier).</p> <p>So, algebraists, then, are interested in functions and substructures of the vector space that preserve the interactions of vectors (which are linear combinations in our case). The substructures of vector spaces that preserve linear combinations are <strong>subspaces</strong>, and the functions that preserve linear combinations are called <strong>Linear Transformations</strong>. Our focus today is on linear transformations, though.</p> \[\begin{gather*} T(v)=T(c_1v_1+\ldots+c_nv_n)\\=c_1T(v_1)+\ldots+c_nT(v_n) \end{gather*}\] <p>But why are <em>you</em> (someone who is probably <em>not</em> an algebraist) interested in functions that preserve linear combinations? Well, if you’re taken calculus, then you definitely are! How do you take the derivative of a polynomial?</p> \[\frac{d}{dx}(ax^2+bx+c)=a\frac{d}{dx}x^2+b\frac{d}{dx}x+c\frac{d}{dx}1\] \[=a(2x)+b(1)+c(0)=2ax+b\] <p>You probably don’t think about it that way (with so many steps), and you can just <em>see</em> the derivative. But this is really what’s going on under the hood. We don’t have an explicit formula for the derivative of every single polynomial that exists, but we do know</p> <ul> <li>The derivative of any single power of \(x\): \(\frac{d}{dx}x^n=nx^{n-1}\).</li> <li>We can just take constants “along for the ride”. That is, we can pull scalars out of a derivative.</li> <li>We can <em>also</em> separate the derivative of a sum into the sum of derivatives.</li> </ul> \[\begin{gather*} \frac{d}{dx}(cf(x))=c\frac{d}{dx}f(x)\\ \frac{d}{dx}(f(x)+g(x))=\frac{d}{dx}f(x)+\frac{d}{dx}g(x)\\ \end{gather*}\] <p>We can combine these properties to just say the derivative “preserves” linear combinations:</p> \[\frac{d}{dx}(c_1f(x)+c_2g(x))=c_1\frac{d}{dx}f(x)+c_2\frac{d}{dx}g(x)\] <p>and so differentiating a polynomial is just breaking up the linear combination and applying the derivative to each power of \(x\). This is the key idea: we only need to know how the operation acts on each vector, and then we know exactly how it acts on any linear combination of those vectors. We don’t need to compute it from scratch.</p> <p>And, in that way, the derivative is one of the most important examples of a linear transformation (<a href="../linalglinconstcoef/" target="_blank">and the study of the derivative as a linear operator on smooth functions is pretty much the most important part of an Ordinary Differential Equations course</a>). The integral can also be considered a linear operator.</p> <p>Hopefully, the derivative and integral are sufficient to convince you that “yeah, studying linear operators might be worth doing”, but in case you need a few more, the following are examples of things that are actually just applications of linear transformations:</p> <ul> <li>Systems of linear equations</li> <li>State changes (Markov chains, PageRank algorithms)</li> <li>Adjacency matrices for a graph</li> <li>Fourier and Laplace transforms</li> </ul> <h2 id="representing-a-linear-transformation">Representing a linear transformation</h2> <p>Alright, so I’ll assume you’re on board with “linear transformations are worth studying”. Now, we’re going to restrict ourselves to linear transformations between finite dimensional vector spaces (the main topic for an introductory course in linear algebra). For our purposes, a finite dimensional vector space is necessary because it has a finite basis, which is the key fact that makes matrices so useful.</p> <p>Now, what do I mean by finite basis? Well, let’s focus on the main dish of finite dimensional vector spaces: coordinate spaces! You might know them in the case of \(F=\mathbb{R}\) as “Euclidean vector spaces” of the form \(\mathbb{R}^n\). We’ll just call them \(F^n\): an array or list of \(n\) numbers from the underlying field of scalars (which we’re just calling \(F\) instead of specifying \(\mathbb{R}\) or \(\mathbb{C}\) or whatever other field have).</p> <p>Note: One of the reasons linear algebra is so powerful is that all the non \(F^n\) finite dimensional vector spaces are actually just isomorphic to \(F^n\) by the coordinate map. In layman’s terms: it’s all just \(F^n\). We can without loss of generality assume we’re taking about \(F^n\) coordinate spaces, which mesh the best with matrices. And then we only have to slightly adjust the execution for general finite dimensional vector spaces.</p> <h3 id="basis">Basis</h3> <p>Okay, so why do we care about a “basis”, and what is it? A <strong>basis</strong> is a “generating set” of vectors with unique representations. What does that mean?</p> <h4 id="span-and-generating-sets">Span and generating sets</h4> <p>The fact that it’s a “generating set” means that the basis can “generate” or produce any vector in the space. If a vector exists in the space, I can give you a linear combination of the basis vectors that equals that vector. If our basis is \(\left\{v_1,\ldots,v_n\right\}\), then that means for all \(x\in F^n\), we can find constants \(c_1,\ldots, c_n\) depending on \(x\) such that</p> \[x=c_1v_1+\ldots+c_nv_n\] <p>You probably learned the word “span” to describe this concept, but “generate” is a more descriptive word (in my opinion), <em>and</em> the more general term used for similar concepts in abstract algebra. But it’s still the same thing: we’ll use “generates” as a synonym for “spans”.</p> <p>For example, take \(F^2\) with the standard basis \(\left\{\begin{pmatrix}1\\0\end{pmatrix},\begin{pmatrix}0\\1\end{pmatrix}\right\}\). For any vector in the space, \(x=\begin{pmatrix}x_1\\x_2\end{pmatrix}\), we can easily find a linear combination of the basis vectors to reach \(x\):</p> \[x=\begin{pmatrix}x_1\\x_2\end{pmatrix}=x_1\begin{pmatrix}1\\0\end{pmatrix}+x_2\begin{pmatrix}0\\1\end{pmatrix}\] <p>The constants in the linear combination are just the entries! That’s what makes this the “standard basis”. It’s the simplest possible basis, which is easiest to use. We’ll use \(e_i\) for the \(i\)th standard basis vector (that is, a \(1\) in the \(i\)th entry and zeroes everywhere else).</p> <p>I would like to remark about the connection between span/generation and the substructure I mentioned earlier: “subspaces”. A subspace is a subcollection of vectors which are <strong>closed</strong> under linear combinations. Meaning any linear combinations of vectors in the subspace is still in the subspace. It turns out that subspaces are exactly just spans of some generating set. That is, every subspace is the span of some basis for the subspace, and every span of a set of vectors is itself a subspace. But it’s better to think of span and subspace being synonymous ideas, rather than a happenstance. Our primary interaction of vectors is linear combinations, and span is just taking <em>all</em> linear combinations. Can you justify why that would necessarily form a closed structure under linear combinations? The other direction is slightly more tricky: that any structure closed under linear combinations can be represented as a span. But it follows from the axiom of choice that any vector space (and any subspace is itself a vector space) has a basis (and, thus, a generating set).</p> <p>Later I mention the row space and column space of a matrix. These are examples of subspaces which are defined by being generated by the rows or columns respectively. Note that the kernel is also a subspace.</p> <h4 id="linear-independence">Linear independence</h4> <p>Now, there’s one other part from the definition for basis I gave above: the generating set has “unique representation”, which essentially means that it’s “linearly independent”. This means that the representation of a vector as a linear combination of the basis vectors is unique. So if we have</p> \[x=c_1v_1+\ldots+c_nv_n=d_1v_1+\ldots+d_nv_n\] <p>Then that implies that \(c_i=d_i\) for all \(i\).</p> <p>Now, if you’ve already learned linear independence, you might be thinking “WTF THIS IS NOT WHAT I LEARNED LINEAR INDEPENDENCE MEANS”. And, yes, this is not the standard definition. But it is the most <em>conceptually useful</em> definition, especially for our purposes here (though not the easiest to use for proofs). See, if we stick with just this idea of “unique representations”, then what if \(x=0\)? We can clearly use \(d_1=\ldots=d_n=0\) as a linear combination to get \(x\) because \(0v_1+\ldots+0v_n=0\). However, this means that, by our established uniqueness,</p> \[c_1v_1+\ldots+c_nv_n=0\implies c_1=\ldots=c_n=0\] <p>All the \(c_i\)’s must be zero! And <em>this</em> is now closer to what you probably learned before. In fact, you can actually read the more familiar definition as saying “the zero vector can only (uniquely) be represented as a linear combination of these vectors using the trivial linear combination of all zero coefficients (trivial solution)”. And, as it turns out, if \(0\) can only be represented by the trivial solution, then that means ALL representations are unique! This is not as obvious (and worth trying to prove if you can)!</p> <p>The other super important and useful fact: <strong>all bases have the same size!</strong> Don’t take this for granted, the fact we’re over a field is the only reason this is guaranteed to be true. There are Modules which can have a generating sets of any positive integer size which are <em>all</em> linearly independent. For us, it’s SUPER simple: <strong>\(F^n\) has \(n\) basis vectors</strong>. Don’t overthink it!</p> <p>Okay, so basically I took your familiar “basis” = “spans” + “linearly independent” definition, and slapped on confusing words: “spans” = “generates” and “linearly independent” = “unique representations”. Why? Because now everything is going to come together.</p> <h3 id="all-together-now">All together now</h3> <p>Okay, so to summarize so far:</p> <ul> <li>We have vector spaces over some field which contain vectors that we can take linear combinations of.</li> <li>We’re interested in functions called Linear Transformations that preserve linear combinations.</li> <li>If the vector space is finite dimensional, then we have some finite basis.</li> <li>A basis gives a way to uniquely write any vector in the space.</li> </ul> <p>We’re going to use these facts together to get the main reason linear transformations are so nice and easy to study: <strong>To know how it acts on ANY vector, we ONLY need to know how it acts on the BASIS vectors of the domain.</strong></p> <p>This is <strong>HUGE</strong>. Functions can be very complicated and complex! It can be computationally intense to even compute many functions. But with linear transformations between finite dimensional vector spaces? Easy-peasy. Because if \(T\) is a linear transformation from \(F^n\to F^m\), then we only need to know the images of the \(n\) basis vectors of \(F^n\) to know where \(T\) sends <strong>EVERY</strong> vector. (I feel like you aren’t getting as excited about this as I am)</p> <p>So suppose you are trying to tell your friend across the sea about your interesting linear transformation between \(\mathbb{R}^3\to \mathbb{R}^2\). How do you do it? \(\mathbb{R}^3\) has infinitely many vectors (uncountably many, in fact). You could never write down every image (output) for every vector in \(\mathbb{R}^3\). But, you don’t need to! For,</p> \[\begin{multline*} T\begin{pmatrix}x_1\\x_2\\x_3\end{pmatrix}=T(x_1e_1+x_2e_2+x_3e_3)\\=x_1T(e_1)+x_2T(e_2)+x_3T(e_3) \end{multline*}\] <p>Therefore, all we need is \(T(e_1),T(e_2),T(e_3)\). That’s just three \(\mathbb{R}^2\) vectors: which is \(6\) simple numbers total. That means, all you need to send to your friend is those six numbers, and they will have EXACTLY your linear transformation. Let’s say the images are</p> \[T(e_1)=\begin{pmatrix}1\\1\end{pmatrix},\quad T(e_2)=\begin{pmatrix}0\\1\end{pmatrix},\quad T(e_3)=\begin{pmatrix}1\\-1\end{pmatrix}\] <p>So, if you were lazy, and you wanted to send those six numbers to your friend in as clear and simple a way as possible, how might you do it?</p> <p>Well sending just <code class="language-plaintext highlighter-rouge">1,1,0,1,1,-1</code> is kind of confusing and hard to parse. It’s also not immediately clear what this is a transformation between. It could be \(\mathbb{R}^1\) to \(\mathbb{R}^6\) or vice versa, or \(\mathbb{R}^2\) to \(\mathbb{R}^3\). So a one-dimensional array doesn’t really work.</p> <p>Okay, you know exactly what I’m getting at: YOU PUT IT IN A <strong>MATRIX</strong>. A <strong>TWO</strong>-dimensional array. And we have the vectors already in their little column form, why not just concatenate them? Let’s define</p> \[A=\begin{pmatrix}1&amp;0&amp;1\\1&amp;1&amp;-1\end{pmatrix}\] <p>to be our little package that <em>encodes</em> \(T\). This perfectly stores all the information we need to communicate \(T\). Each column tell us the image of each standard basis vector.</p> <p>Now, let’s take it one step further. What if we could use \(A\) <em>instead</em> of \(T\)? What if we didn’t have to write the linear transformation at all? What if we could stick to just these simple arrays of numbers to carry <strong>all</strong> the information of our linear transformation? How would we do it?</p> <p>Well we clearly want \(Ax=T(x)\). That much is obvious. And we know that</p> \[T\begin{pmatrix}x_1\\x_2\\x_3\end{pmatrix}=x_1\begin{pmatrix}1\\1\end{pmatrix}+x_2\begin{pmatrix}0\\1\end{pmatrix}+x_3\begin{pmatrix}1\\-1\end{pmatrix}\] <p>So… then… let’s just define</p> \[\begin{multline*} \begin{pmatrix}1&amp;0&amp;1\\1&amp;1&amp;-1\end{pmatrix}\begin{pmatrix}x_1\\x_2\\x_3\end{pmatrix}\\ =x_1\begin{pmatrix}1\\1\end{pmatrix}+x_2\begin{pmatrix}0\\1\end{pmatrix}+x_3\begin{pmatrix}1\\-1\end{pmatrix} \end{multline*}\] <p>And there, now we have matrix vector multiplication defined.</p> <p>Essentially, all we’re doing is</p> \[\begin{equation} A= \Bigg(\begin{matrix}T(e_1)&amp;\cdots&amp;T(e_n)\end{matrix}\Bigg) \end{equation}\] <p><img src="/assets/img/all%20coming%20together.png" alt="all coming together" style="width:100%; max-width:600px;"></p> <p>Observe that this also, at a glance, tells us exactly what \(T\) is a function between. Each column has two entries (i.e. \(A\) has two rows), so the codomain must be \(\mathbb{R}^2\). We also have three columns, so our domain has three basis vectors. Clearly, the domain must be \(\mathbb{R}^3\). Thus, our construction of \(A\) as a “package” for \(T\) means that \(A\) being \(m\times n\) (\(m\) rows and \(n\) columns) means that the linear transformation that \(A\) encodes is from \(F^n\to F^m\).</p> <p>I’d like to acknowledge that with this perspective, a student doesn’t have to “memorize” the fact that \(m\times n\iff F^n\to F^m\). This isn’t a “theorem” or something that requires excessive scratch work. This is a damn <strong>feature</strong> of matrices, which makes them so informative and useful. Not only do the columns encode the outputs, the very <strong>shape</strong> itself tells you one of the most important aspects of the function: the dimension of the domain and codomain (AND their size relative to each other).</p> <p>So by our construction, this allows us to utilize other theorems to know from a glance that</p> <ul> <li>A wide matrix has a nontrivial kernel (is not injective)</li> <li>A tall matrix is not surjective</li> </ul> <h3 id="change-of-basis">Change of basis</h3> <p>Now, it’s time for my trump card. Why you should <em>definitely</em> view a matrix from the perspective that the columns are the images of the basis vectors. Because that’s how we define a matrix for a linear transformation with respect to <em>other</em> bases! If your course covers finding a matrix with respect to a certain basis, then you <em>absolutely</em> should start with this perspective.</p> <p>I see it, time and time again. A student asks how to find the matrix for \(T\) with respect to some given basis \(\beta\) (or maybe just the matrix for a described linear transformation), and they’re lost. And the inevitable first question someone asks the student is “do you know the ‘formula’ for the matrix with respect to the basis \(\beta\)?”</p> \[[T]_\beta^\gamma = \Bigg(\begin{matrix}\left[T(\beta_1)\right]_\gamma&amp;\cdots&amp;\left[T(\beta_n)\right]_\gamma\end{matrix}\Bigg)\] <p>But, really, this is the <strong>definition</strong> for the matrix representation for a given linear transformation when bases are specified for the domain and codomain. Now, if you adopt the view I’m trying to push here, then this definition is just… the natural generalization. The columns are still just the images of the basis vectors of the domain, we’re just being more explicit that we’re using a specific basis. But now we make sure the images are the coordinates with respect to the proper basis of the codomain. That is literally the only change. If both \(\beta\) and \(\gamma\) are just the standard basis of \(F^n\) and \(F^m\) respectively, it’s <em>exactly</em> what we described above.</p> <p>If you haven’t learned coordinate vectors or change of basis, you can ignore this. But just know that this is <em>literally</em> how we define the matrix representation of a linear transformation!</p> <p><a href="https://youtu.be/t348e24vDyA?si=k3Df2elcbvqxdcnq" target="_blank" rel="external nofollow noopener">So why isn’t this view emphasized at the beginning of a course so that this generalization to other bases is only a minor change and not something students seem to need to learn from scratch? Why is this viewed as a formula and not the most basic definition?</a></p> <h2 id="column-perspective">Column Perspective</h2> <p>In case you’ve seen me rant online about how column perspective is the ultimate definition of matrix vector multiplication, perhaps now you can see why I think so. With our perspective of a matrix as a compact definition for a linear transformation, this definition is just obvious.</p> \[\begin{equation} \Bigg(\begin{matrix}a_1&amp;\cdots&amp;a_n\end{matrix}\Bigg) \begin{pmatrix}x_1\\\vdots\\x_n\end{pmatrix} =x_1a_1+\ldots+x_na_n \end{equation}\] <p>where \(a_i\) is the \(i\)th column of \(A\) (which, by definition, is \(Ae_i\)). As a side note, the following two facts are things that most students I’ve worked with don’t find obvious, but really are with this perspective:</p> <ul> <li>The \(i\)th column of \(A\) has the preimage \(e_i\) (i.e. is equal to \(Ae_i\)). Again, literally <em>by definition</em>.</li> <li>If \(A\) is square and the \(i\)th column of \(A\) is a scalar multiple of \(e_i\), then \(e_i\) is an eigenvector.</li> </ul> <p>Observe, also, that taking some linear combination of the columns is the same as just taking the image of the vector with the scalars as the entries. That is, \(c_1a_1+c_2a_2+\ldots+c_na_n=A\begin{pmatrix}c_1\\\vdots\\c_n\end{pmatrix}\). Hence, if you can find some combination of the column that gives you zero, then that gives you a vector in the kernel.</p> \[c_1a_1+\ldots+c_na_n=0\implies \begin{pmatrix}c_1\\\vdots\\c_n\end{pmatrix}\in\ker(A)\] <p>More generally, if you can find a combination of the columns to give you some vector \(b=c_1a_1+c_2a_2+\ldots+c_na_n\), then \(\begin{pmatrix}c_1\\\vdots\\c_n\end{pmatrix}\) is a preimage of \(b\) under \(A\) (and thus a solution to \(Ax=b\)).</p> <p>So, then how does matrix-matrix multiplication fit into this perspective? Well, if \(T_A\) has the matrix \(A\), and \(T_B\) has the matrix \(B\) (and \(T_B\circ T_A\) is defined), then we want \(BAx=T_B(T_A(x))\). Once again, we just need to make sure that both \(BA\) and \(T_B\circ T_A\) map the standard basis vectors to the same thing.</p> \[T_B(T_A(e_j))=T_B(a_j),\quad BAe_j=Ba_j\] <p>And with our definition, there’s nothing immediately wrong or strange we have to do. We just define the \(j\)th column of \(BA\) to be \(Ba_j\). That is,</p> \[\begin{equation} BA=B\Bigg(\begin{matrix}a_1&amp;\ldots&amp;a_n\end{matrix}\Bigg) =\Bigg(\begin{matrix}Ba_1&amp;\ldots&amp;Ba_n\end{matrix}\Bigg) \end{equation}\] <p>If you think about it, this is actually quite reasonable. \(Ax\) is going to be some linear combination of the columns of \(A\). And \(B(Ax)\) is just applying \(B\) to every single one of those vectors in the linear combination. So the image of the standard basis vectors under \(BA\) is just \(B\) applied to the images of the standard basis vectors under \(A\).</p> <p>Am I going to talk about the row column rule now? No. Because there are a million videos on youtube about it, and your professor probably drilled it into your head. This post is focused on <em>intuition</em>. It doesn’t take that long to see that the row column rule follows directly from the column definition, once you just combine it all into one vector. To be clear, the row column rule is not evil, and I definitely use it because it’s quicker. But I think it’s better to keep in mind the column definition is really <em>the</em> ultimate definition, and it ties pretty much <em>everything</em> you do with matrices together.</p> <p><img src="/assets/img/all%20coming%20together.png" alt="yes i'm using it again" style="width:100%; max-width:600px;"></p> <h3 id="a-remark-on-column-space">A remark on column space</h3> <p>Alright, so at the beginning I talked about how we call the set of all outputs of a function the “image” or “range”. For some reason, in linear algebra, we try to obscure the connection between the image/range of a linear transformation and the image/range of a matrix function by calling it a different name: “the column space of \(A\)”. This is an intuitive name for the span/set of all linear combinations of the columns of \(A\), but it distracts from the fact that we already define multiplication by \(A\) to be <em>taking linear combinations of the columns of \(A\)</em>.</p> <p>This is one of the most frustrating parts of tutoring linear algebra for me. Because for most students, span, column space, and range are basically separate concepts in their head, when it’s really just <em>one</em> thing. The fact that</p> <blockquote> <p>”\(Ax=b\) is consistent if and only if \(b\) is in the column space of \(A\)”</p> </blockquote> <p>has to be a <em>theorem</em> and is not as self-evident as “\(f(x)=y\) is possible if and only if \(y\) is an output of \(f\)” makes me want to tear my hair out. And it’s not the student’s fault! It’s how they’re being taught linear algebra.</p> <p>So screw “column space” (and “null space” for that matter). All matrix functions in linear algebra are linear transformations, and we’re interested in the image and kernel of them. Consider this yeeting two redundant terms from the subject entirely.</p> <p>(Plus, you’ll always sound smarter if you say “image” and “kernel” instead of “column space” and “null space”)</p> <h2 id="column-relationships">Column relationships</h2> <p>Alright, let’s talk about a new matrix \(A=\begin{pmatrix}1&amp;-1&amp;1&amp;2\\1&amp;-1&amp;2&amp;3\\1&amp;-1&amp;3&amp;4\end{pmatrix}\). This is a \(3\times4\) matrix, so it’s a transformation from \(F^4\to F^3\). Now, as is usual in linear algebra, we’re interested in the image and kernel of this linear transformation.</p> <p>The matrix is wider than it is tall, and so it’s trying to stuff a higher dimensional space into a lower dimensional one. Thus, it’s intuitive that we’ll have a nontrivial kernel. A wider matrix <em>can</em> map to the entire codomain, but it’s not immediately obvious if every vector in \(F^3\) <em>will</em> actually have a preimage under \(A\). It’s not even immediately obvious how you’d even determine that! All we theoretically know is that an output is a linear combination of the columns. So, can we reach any \(F^3\) vector with a linear combination of these columns? If not, how can we tell?</p> <p>Well, if we think about it, what we really <em>want</em> is a basis for the range of \(A\). Of course, every column is in the range, so we just want to know which columns to take for a basis, and which columns are redundant. If we look carefully, we can see one major relationship: Column 2 = -(Column 1). This means that if we use both columns one and two, then our representations won’t be unique (because they are linearly dependent). So we should definitely exclude column 2.</p> <p>If we look at Column 3, it doesn’t have any obvious relationship to Column 1. In fact, you can show they are linearly independent. But, you might just notice that Column 4 = Column 1 + Column 3. Another dependence relationship. Thus, it appears that we also have to exclude Column 4, leaving just Columns 1 and 3. Hence,</p> \[\left\{\begin{pmatrix}1\\1\\1\end{pmatrix},\begin{pmatrix}1\\2\\3\end{pmatrix}\right\}\] <p>is a basis for the image of \(A\). You can confirm this is true, because we can write every column of \(A\) as a linear combination of these vectors, so then we can write any linear combination of the columns as a linear combination of these vectors. And from here, we can see that the image is two-dimensional, so it won’t span or generate \(F^3\). Thus, \(A\) is not a surjective or onto transformation.</p> <p>But what of the kernel? Well, Column 2 = -(Column 1) is actually just saying</p> \[A(e_2)=-A(e_1)\implies A(e_1+e_2)=0\] <p>So \(\begin{pmatrix}1\\1\\0\\0\end{pmatrix}\) is in the kernel. Can you see how by similar logic \(\begin{pmatrix}1\\0\\1\\-1\end{pmatrix}\) is also in the kernel? You can verify it yourself by applying \(A\) to both vectors, and when you use column perspective, it should become clear. And we can justify through rank-nullity that these bases are complete because their sizes sum to the dimension of the domain (but let’s just vibe it).</p> <p>Okay, so I lead you through a problem you would have learned to do by row reduction without it. Any liquored-up hillbilly with a shotgun could have done that at the zoo. (TODO: remove this)</p> <p>Let’s try a much easier, <em>seemingly unrelated</em> problem:</p> \[R=\begin{pmatrix}1&amp;-1&amp;0&amp;1\\0&amp;0&amp;1&amp;1\\0&amp;0&amp;0&amp;0\end{pmatrix}\] <p>Here, it’s so much easier to find a basis for the image and kernel. Every column is a linear combination of the independent vectors \(e_1,e_2\), so they form a basis for the image. Oh, and look! Column 1 is \(e_1\) and Column 3 is \(e_2\). So Column 1 and Column 3 themselves form a basis for the image.</p> <p>As for the kernel, clearly if we take Column 1 + Column 2, we’ll cancel them out and get zero. So actually similar to above \(\begin{pmatrix}1\\1\\0\\0\end{pmatrix}\) is in the kernel. And, similarly, it’s pretty easy to see that if we take Column 4 and then subtract off Columns 1 and 3, then that’s also zero. So \(\begin{pmatrix}1\\0\\1\\-1\end{pmatrix}\) is also in the kernel. Now… that seems familiar. Both \(A\) and \(R\) have the same kernel, the same column relationships, and the same columns form a basis for the image*. What is this sorcery??</p> <p>Note*: It turns out that the kernel actually uniquely determines which columns can be a basis for the image.</p> <h2 id="row-reduction">Row reduction</h2> <p>It turns out that \(A\) and \(R\) are actually significantly linked. Because \(R\) can be obtained from \(A\) by applying an invertible operator on the left:</p> \[\begin{pmatrix} 0 &amp; 3 &amp; -2 \\ 0 &amp; -1 &amp; 1 \\ 1 &amp; -2 &amp; 1 \end{pmatrix}\begin{pmatrix}1&amp;-1&amp;1&amp;2\\1&amp;-1&amp;2&amp;3\\1&amp;-1&amp;3&amp;4\end{pmatrix} =\begin{pmatrix}1&amp;-1&amp;0&amp;1\\0&amp;0&amp;1&amp;1\\0&amp;0&amp;0&amp;0\end{pmatrix}\] <p>And since it’s invertible, we can also obtain \(A\) from \(R\) by applying the inverse on the left.</p> <p>Note: If you want to know how I found the matrix, you can just augment \(A\) with the identity and row reduce. You will get \(R\) augmented with a matrix that puts \(A\) into its RREF.</p> <p>So the question becomes “why does applying an invertible operator on the left not change the kernel or column relationships”? Well, like I said above, it turns out that the kernel actually uniquely determines the column relationships of the matrix. See <a href="#Kernel%20determines%20RREF">the end of the post</a> for an algorithm that gives you the unique set of nonzero RREF rows that has the specified kernel.</p> <p>So then why does applying an invertible operator on the left preserve the kernel? Well, this is actually a lot easier. If \(E\) is invertible, then</p> \[Ax=0\iff EAx=0\] <p>So if \(EA=R\), then \(Ax=0\iff Rx=0\implies \ker(A)=\ker(R)\).</p> <p>So, in summary, invertible operations on the left of a matrix don’t change the kernel, which also tell us which choices of columns give us a basis for the image.</p> <h3 id="row-space">Row space</h3> <p>There is another perspective for what an “invertible operator on the left” actually means using <a href="../columnperspective/#row-perspective" target="_blank">“row perspective”</a>. It’s essentially the transpose of column perspective.</p> \[\begin{equation} AB=\begin{pmatrix} {A}_1^T\\{A}_2^T\\\vdots\\{A}_m^T \end{pmatrix}{B}= \begin{pmatrix} {A}_1^T{B}\\{A}_2^T{B}\\\vdots\\{A}_m^T{B} \end{pmatrix} \end{equation}\] <p>Where we are denoting the \(i\)th row of \(A\) as \(A_i^T\).</p> <p>If we think about what \(x^TB\) means, it’s just the transpose of \(B^Tx\), which is taking a linear combination of the columns of \(B^T\), which are the rows of \(B\). Then \(x^TB\) is just a row vector which is a linear combination of the rows of \(B\). Thus, the rows of \(AB\) are just linear combinations of the rows of \(B\). This means that every row of \(AB\) is in the row space of \(B\), and if \(A\) is <em>invertible</em>, then the row space of \(B\) is going to be entirely preserved!</p> <p>This is where elementary matrices come into play. It’s a nifty theorem that every invertible matrix is some product of elementary matrices. That is, any invertible matrix is equivalent to some sequence of row operations. In a way, elementary matrices “generate” the invertible matrices (but not in exactly the same way a set of vectors “generates” or spans a subspace. Here it’s through noncommutative products and not linear combinations).</p> <p>So when we say an “invertible operator on the left”, that can be thought of as performing some elementary row operations. Which, through all we have thus far established, preserves the row space, and thus also the kernel, and thus also the column relationships.</p> <p>In case you forgot, the elementary row operations are the following. I encourage you to convince yourself that these three operations would preserve column relationships.</p> <ol> <li>Swapping rows</li> <li>Scaling a row by a nonzero amount</li> <li>Adding a multiple of one row to another</li> </ol> <p>So, in summary, this is why we do row operations. They preserve the most fundamental aspects of a matrix (besides the image itself): the kernel and which columns generate the image. They can therefore be used to “simplify” a matrix. To its reduced row echelon form, for instance. The RREF, as we have seen, being the clearest and simplest way to see the relationship between the columns of the matrix.</p> <h4 id="row-space-basis">Row space basis</h4> <p>Another quick remark: We’ve established that row reduction preserves the row space. And, looking at the structure of the RREF, it’s clear that the nonzero rows of the RREF are linearly independent. They thus form a basis for the row space. Note also that since we can switch around rows when row reducing, that we must take the RREF rows as our row space basis rather than the corresponding rows of the original matrix. I explain that more in-depth <a href="../rowcolspace/#row-space" target="_blank">here</a>. But I also want to point out the difference in how the RREF gives us a basis for the row space and column space of the original matrix.</p> <p>Since row reduction can swap and change rows, we usually don’t end up with rows from the original matrix, but we do end up with a much nicer basis. Columns, on the other hand, never change their relative position, and that’s one of the reasons the relationships are preserved. However, though the rows of the RREF are still in the row space (just linear combinations of the original), the resulting columns are almost always completely different. This is why we go back to the original matrix. But this means that our column space basis is usually not as nice.</p> <p>In summary: the RREF of \(A\) gives a nicer row space basis not usually containing the rows of \(A\), while it gives a not so nice column space basis using the original columns of \(A\). This means that the RREF of \(A^T\) gives a nicer column space basis for \(A\) not in terms of the original columns, but a not so nice basis for the row space of \(A\) in terms of the original rows.</p> <p>All this to say, that row reduction not only shows us the relationships between the columns, but it also gives us the nicest possible basis for the rows. That means, we can also use the RREF to get the nicest possible basis for the span of any arbitrary set of vectors by sticking the vectors as the rows of a matrix and row reducing. Functionally also giving us a way to determine dimension computationally: just count the number of nonzero rows of the RREF.</p> <h3 id="solving-systems-of-equations">Solving systems of equations</h3> <p>Now, you may realize that I’m <em>only</em> getting to <em>solving</em> systems of equations <em>now</em>. And this may be surprising because row operations and matrices are often introduced FOR solving systems of equations. But hear me out! Everything we have talked about thus far is going to make row reduction’s application to solving systems of equations extremely simple and intuitive.</p> <p>See, we have thus far established row operations and row reduction as a way to see and make clear the relationship between a matrix’s columns. That is, row reduction can allow us to more easily see how to write one column as a linear combination of the others. Let’s see how this applies to systems of equations.</p> <p>A system of equations has approximately four “forms”. The one we use most commonly is \(Ax=b\). Each perspective has its own intuitive benefit. \(Ax=b\), for example, emphasizes that we’re trying to find a preimage under the linear transformation defined by \(A\). For example,</p> \[\begin{pmatrix}1&amp;-1&amp;1\\1&amp;-1&amp;2\\1&amp;-1&amp;3\end{pmatrix}x=\begin{pmatrix}2\\3\\4\end{pmatrix}\] <p>But we can also write it in</p> <ul> <li>Equation form: Emphasizes that we are trying to simultaneously satisfy multiple constraints.</li> </ul> \[\begin{matrix}1x_1&amp;-&amp;1x_2&amp;+&amp;1x_3&amp;=&amp;2\\1x_1&amp;-&amp;1x_2&amp;+&amp;2x_3&amp;=&amp;3\\1x_1&amp;-&amp;1x_2&amp;+&amp;3x_3&amp;=&amp;4\end{matrix}\] <ul> <li>Vector form: Column perspective, basically. Emphasizes we are trying to write one vector as a linear combination of some starting set of vectors (the columns of \(A\))</li> </ul> \[x_1\begin{pmatrix}1\\1\\1\end{pmatrix}+x_2\begin{pmatrix}1\\1\\1\end{pmatrix} +x_3\begin{pmatrix}1\\2\\3\end{pmatrix}=\begin{pmatrix}2\\3\\4\end{pmatrix}\] <ul> <li>Augmented matrix form: The most compact form of the system, and is going to be our secret weapon using the view we’ve built up in this post.</li> </ul> \[\left(\begin{array}{ccc\|c}1&amp;-1&amp;1&amp;2\\1&amp;-1&amp;2&amp;3\\1&amp;-1&amp;3&amp;4\end{array}\right)\] <p>You may have noticed that this augmented matrix is the matrix \(A\) from the <a href="#column-relationships">Column relationships</a> section! Recall that we found that Column 4 = Column 1 + Column 3. That is,</p> \[\begin{pmatrix}1\\1\\1\end{pmatrix} +\begin{pmatrix}1\\2\\3\end{pmatrix}=\begin{pmatrix}2\\3\\4\end{pmatrix}\] <p>And, again, we can easily see this is true by looking at the RREF:</p> \[\left(\begin{array}{ccc\|c}1&amp;-1&amp;1&amp;2\\1&amp;-1&amp;2&amp;3\\1&amp;-1&amp;3&amp;4\end{array}\right) \sim \left(\begin{array}{ccc\|c}1&amp;-1&amp;0&amp;1\\0&amp;0&amp;1&amp;1\\0&amp;0&amp;0&amp;0\end{array}\right)\] <p>This may seem completely inconsistent with how you learned it. You probably learned to just row reduce and then turn it back into equation form. Which would be</p> \[\begin{matrix}1x_1&amp;-&amp;1x_2&amp;&amp;&amp;=&amp;1\\&amp;&amp;&amp;&amp;x_3&amp;=&amp;1\end{matrix}\] <p>And then solve for the pivot variables blah blah blah. But, instead, you could just look at the columns.</p> <p>The augmented column 4, or \(b\) column, is Column 1 + Column 3. So a <strong>particular solution</strong> is \(\begin{pmatrix}1\\0\\1\end{pmatrix}\). We can identify that the kernel vector, or <strong>homogeneous solution</strong>, associated with the nonpivot column (Column 2) of the coefficient matrix is \(\begin{pmatrix}1\\1\\0\end{pmatrix}\) because Column 1 + Column 2 = 0. And that gives us our <strong>general solution</strong>: a particular solution plus a linear combination of the homogeneous solutions (a basis of the kernel of the coefficient matrix).</p> \[x=\begin{pmatrix}1\\0\\1\end{pmatrix}+c\begin{pmatrix}1\\1\\0\end{pmatrix}\] <p>I’m not saying this is the one only good way to solve systems, but I’m trying to convey the fact that with this perspective of matrices, matrix multiplication, and row reduction I’ve set up, the application to solving system of equations is clear and intuitive, and it can be explained in a way that all of these concepts can be tied together.</p> <p><img src="/assets/img/all%20coming%20together.png" alt="yes i'm using it again again" style="width:100%; max-width:600px;"></p> <h3 id="kernel-determines-rref">Kernel determines RREF</h3> <p>Alright, now I didn’t want to stick this in the middle of the post. I had a sort of rage flow going. But this is an algorithm that allows you to determine the RREF directly from the kernel. Specifically, from the kernel alone you can actually determine exactly what the nonzero rows of rref(\(A\)) must be. Here’s how:</p> <ol> <li>Put your basis for \(\ker(A)\) as the rows of a matrix</li> <li>row reduce and find the kernel of that new matrix</li> <li>take the basis of that new kernel as the rows of <em>another</em> matrix and row reduce</li> <li>the result will be the nonzero rows of rref(\(A\)).</li> </ol> <p>The algorithm is mostly just something for you to think about. It’s a little advanced to explain exactly why it works, but it has to do with the fact that the row space is the orthogonal complement of the kernel, and the nonzero rows of the RREF are just a specific form of basis for the row space. I encourage you to try to think it through.</p> <p><a href="https://youtu.be/NtiGP0MlF8k?si=T5evvei871Yl76GT" target="_blank" rel="external nofollow noopener">hyperlink</a></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: July 29, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>