<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Constant Coefficient ODEs Made Simple with Linear Operators | smashmath</title> <meta name="author" content=" "> <meta name="description" content="No more guessing. Let's make it intuitive with linear algebra."> <meta name="keywords" content="math, blog"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%98%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://smashmath.github.io/blog/linalglinconstcoef/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Constant Coefficient ODEs Made Simple with Linear Operators",
      "description": "No more guessing. Let's make it intuitive with linear algebra.",
      "published": "November 11, 2023",
      "authors": [
        {
          "author": "Taylor F.",
          "authorURL": "",
          "affiliations": [
            {
              "name": "None",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">smashmath</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Constant Coefficient ODEs Made Simple with Linear Operators</h1> <p>No more guessing. Let's make it intuitive with linear algebra.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#linear-algebra-recap">Linear Algebra Recap</a></div> <ul> <li><a href="#linear-transformations">Linear Transformations</a></li> <li><a href="#eigenvectors">Eigenvectors</a></li> <li><a href="#linear-operators-and-polynomials">Linear Operators and Polynomials</a></li> </ul> <div><a href="#the-differential-operator">The Differential Operator</a></div> <div><a href="#the-most-important-ode">The Most Important ODE</a></div> <div><a href="#repeated-roots">Repeated Roots</a></div> <ul> <li><a href="#exponential-shift">Exponential Shift</a></li> <li><a href="#exponential-shift-into-overdrive">Exponential Shift Into Overdrive</a></li> </ul> <div><a href="#exponential-response-formula">Exponential Response Formula</a></div> <div><a href="#nth-order-n-independent-solutions">nth Order. n Independent Solutions</a></div> <div><a href="#a-remark-on-undetermined-coefficients">A remark on undetermined coefficients</a></div> <div><a href="#complex-stuff">Complex Stuff</a></div> </nav> </d-contents> <p>Last year, I made a post about <a href="../linconstcoef/" target="_blank">this same topic</a>, but since then, I have developed a new way of understanding this topic through the lens of linear algebra which makes many of the seemingly arbitrary choices seem almost stupidly obvious. One time, I was discussing differential equations with a friend of mine at a bar who was taking a class in it at the time. He asked me, “why do we know that the solutions to these equations <em>have</em> to be exponentials?” My explanation was not great, but years later I presented the following explanation to him at a different bar which I think was much better. In his words, it was “mindblowing”. I’m hoping you will feel similarly. <strong>It does, however, require linear algebra.</strong></p> <p>We will address the following questions in the context of constant coefficient linear ordinary differential equations:</p> \[a_ny^{(n)}+\ldots+a_1y'+a_0y=0\] <ol> <li>Why is our guess for the solution \(e^{\lambda t}\)?</li> <li>Why do we multiply by \(t\) when we have a repeated root of the characteristic polynomial?</li> <li>Why does an \(n\)th order equation have exactly \(n\) linearly independent homogeneous solutions?</li> </ol> <p>And as a bonus, I’m going to explain why the <a href="../alphamethod/" target="_blank"><strong>exponential response formula</strong></a> is actually absurdly trivial!</p> <h1 id="linear-algebra-recap">Linear Algebra Recap</h1> <p>Let us review some basic linear algebra facts and terminology.</p> <p>A <strong>subspace</strong> is a nonempty subset of a vector space that is closed under linear combinations.</p> <h2 id="linear-transformations">Linear Transformations</h2> <p>A linear transformation \(T\), is a function that preserves linear combinations.</p> <p>\begin{equation} T(c_1x_1+\ldots+c_kx_k)=c_1T(x_1)+\ldots+c_kT(x_k) \end{equation}</p> <p>The derivative \(\frac{d}{dt}\) is an example of a linear transformation. This is by the linearity of differentiation. That is, by the fact that we can pull out constants from derivatives, and that the derivative of a sum is just the sum of derivatives.</p> <p>If \(T(x)=y\), then we say that \(y\) is the <strong>image</strong> of \(x\) under \(T\) (often, we just say the image of \(x\)). The image is unique because \(T\) is a function. We call \(x\) the <strong>preimage</strong> of \(y\) under \(T\). A preimage is not necessarily unique.</p> <p>If the image of an element \(x\) is \(0\) (\(T(x)=0\)), then we say that \(x\) is in the <strong>kernel</strong> of \(T\) (\(x\in\ker(T)\)). The kernel is the set of all preimages of \(0\). We sometimes call the kernel the set of all <strong>homogeneous solutions</strong> to the equation \(T(x)=0\). The kernel is a subspace.</p> <h3 id="preimage-theorem">Preimage Theorem</h3> <p>Assume the equation \(T(x)=b\) (which is asking the question “what is a preimage of \(b\)?”) has at least one solution, \(x=x_p\). Then <em>every</em> solution is of the form \(x=x_p+x_h\) where \(x_h\) is an element in \(\ker(T)\). That is, <strong>all preimages of a linear transformation are off from a single particular preimage by something in the kernel</strong>.</p> <p><strong>Proof:</strong> If \(x_0\) is a vector of the form \(x_0=x_p+x_h\), then \(T(x_0)=T(x_p+x_h)=T(x_p)+T(x_h)=b+0=b\). Hence, \(x_0\) is also a preimage of \(b\), showing that any vector of this form is also a solution.</p> <p>Suppose we have some other solution \(x_1\). Then \(T(x_1-x_p)=T(x_1)-T(x_p)=b-b=0\). Hence, \(x_1-x_p\in\ker(T)\), so \(x_1-x_p=x_h\) for some \(x_h\in\ker(T)\), and thus \(x_1=x_p+x_h\), concluding the proof. \(\square\)</p> <p>This last step actually implies that a <strong>general solution</strong> to \(T(x)=b\) is an expression of the form</p> \[x=c_1x_1+\ldots+c_nx_n+x_p\] <p>where \(x_1,\ldots,x_n\) form a basis for \(\ker(T)\) and \(x_p\) is any particular solution. This is because if for any solution \(x-x_p\in\ker(T)\), then by establishing a basis \(x_1,\ldots,x_n\) we are saying that \(x-x_p\) can be written in the form \(c_1x_1+\ldots+c_nx_n\).</p> <p>For the derivative operator, the kernel is just the set of all constant functions. Any preimage under the operator is also just an antiderivative. And one of the important theorems of calculus is that any two antiderivatives differ by a constant, which is exactly what the preimage theorem states for this example.</p> <h2 id="eigenvectors">Eigenvectors</h2> <p>An <strong>eigenvector</strong> of \(T\) is a nonzero vector \(v\) for which \(T\) just scales \(v\). That is, \(T(v)=\lambda v\) for some \(\lambda\in F\) (note we are using \(F\) here because this works for any field. Eventually we are going to be assuming \(F\) is \(\mathbb{R}\) or \(\mathbb{C}\)). \(\lambda\) is called the <strong>eigenvalue</strong> of \(v\). Note that this means that</p> \[(T-\lambda I)v=0\implies v\in\ker(T-\lambda I)\] <p>As a very mundane but useful fact, if the eigenvalue of \(v\) is nonzero, then we can just divide both sides of \(T(v)=\lambda v\) by \(\lambda\) to get that \(T\left(\frac{v}{\lambda}\right)=v\implies\frac{v}{\lambda}\) is an easy preimage of \(v\).</p> <p>\begin{equation}\label{divide} T(v)=\lambda v\neq0\implies T\left(\frac{v}{\lambda}\right)=v \end{equation}</p> <p>Another important fact is that \(T^n(v)=\lambda^n v\).</p> <p>We call the set of all eigenvectors with eigenvalue \(\lambda\) the <strong>eigenspace of \(\lambda\)</strong>. The <strong>generalized eigenspace of \(\lambda\)</strong> is the set of all generalized eigenvectors which we denote \(E_\lambda\). Recall that generalized eigenvectors are all vectors \(w\) for which</p> \[(T-\lambda I)^kw=0\] <p>for some integer \(k\).</p> <h2 id="linear-operators-and-polynomials">Linear Operators and Polynomials</h2> <p>Given a polynomial \(p(x)=a_0+a_1x+\ldots+a_nx^n\), we define</p> <p>\begin{equation} p(T)=a_0I+a_1T+\ldots+a_nT^n \end{equation}</p> \[\implies p(T)x=a_0x+a_1T(x)+\ldots+a_nT^n(x)\] <p>Here are some insanely important facts</p> <ol> <li>Polynomials in an operator commute. That is, for all polynomials \(p,q\), \(p(T)q(T)=q(T)p(T)\). This includes the specific case of first order factors \((T-aI)(T-bI)=(T-bI)(T-aI)\).</li> <li>The kernel is just the eigenspace of \(0\). That is, finding the kernel of an operator can be done by finding all eigenvectors with eigenvalue zero.</li> <li>If \(v\) is an eigenvector of \(T\) with eigenvalue \(\lambda\), then \(v\) is also an eigenvector of \(p(T)\) with eigenvalue \(p(\lambda)\) (this is a very good thing to prove, and it’s a very short proof).</li> <li>\(p(T)\) can have eigenvectors that are not eigenvectors of \(T\). One example is that \(\begin{pmatrix}1\\0\end{pmatrix}\) is an eigenvector of \(J=\begin{pmatrix}\lambda&amp;1\\0&amp;\lambda\end{pmatrix}\), but \(\begin{pmatrix}0\\1\end{pmatrix}\) is an eigenvector of \((J-\lambda I)^2=\begin{pmatrix}0&amp;0\\0&amp;0\end{pmatrix}\) and not of \(J\).</li> <li>Combining the above three points tells us that finding all eigenvectors of \(T\) with eigenvalue \(\lambda\) such that \(p(\lambda)=0\) will definitely give a subset of the kernel of \(p(T)\). However, it may not necessarily give a full basis for \(\ker(p(T))\).</li> </ol> <h1 id="the-differential-operator">The Differential Operator</h1> <p>We are going to focus in on the differential operator \(D\) defined by</p> <p>\begin{equation} Dy=y’ \end{equation}</p> <p>This is a linear operator as mentioned before. As a note, we will omit the \(I\) when writing something like \((D-\lambda I)\). We will just write \((D-\lambda)\). Further, \(y^{(k)}=D^ky\).</p> <p>Okay, so now, let’s bring everything we talked about above together:</p> <p>The differential equation</p> <p>\begin{equation} a_ny^{(n)}+\ldots+a_1y’+a_0y=g(t) \end{equation}</p> <p>where the \(a_i\)’s can be complex numbers.</p> \[a_nD^ny+\ldots+a_1Dy+a_0y=g(t)\] \[\left(a_nD^n+\ldots+a_1D+a_0\right)y=g(t)\] <p>is just the equation \(p(D)y=g(t)\), where \(p(x)=a_nx^n+\ldots+a_1x+a_0\). That is, we are looking for preimages of \(g(t)\) under \(p(D)\), and every solution will be of the form \(y=y_p+y_h\) where \(y_p\) is some preimage of \(g(t)\), and \(y_h\) is any vector in the kernel of \(p(D)\). Note that because the kernel is always a subspace, this gives us the superposition property of homogeneous solutions for free.</p> <p>i.e. If \(y_1,\ldots,y_n\) are solutions to \(p(D)y=0\), then so will \(c_1y_1+\ldots+c_ny_n\).</p> <p>As before, to find the <strong>general solution</strong>, we need a basis \(\{y_1,\ldots,y_k\}\) of the kernel of \(p(D)\). Then, any solution \(y\) can be written as</p> \[y=y_p+c_1y_1+\ldots+c_ky_k\] <p>So how can we start to find a basis for the kernel? And how many vectors will be in it? Well, we know that any eigenvector of \(D\) with eigenvalue \(\lambda\) will be an eigenvector of \(p(D)\) with eigenvalue \(p(\lambda)\). So we can try to find some solutions by solving \(p(\lambda)=0\).</p> \[p(\lambda)=a_n\lambda^n+\ldots+a_1\lambda+a_0=0\] <p>And there we go: the characteristic polynomial is now something obvious to try, and we have yet to even <em>mention</em> exponentials.</p> <p>So let \(\lambda\) be any solution to \(p(\lambda)=0\). Now we are looking for eigenvectors \(y\) of \(D\) with eigenvalue \(\lambda\). That is, we want \(Dy=\lambda y\implies y'=\lambda y\).</p> <h1 id="the-most-important-ode">The Most Important ODE</h1> <p>\begin{equation} y’=\lambda y \end{equation}</p> <p>Yeah, I said it.</p> <p>Just getting down to business solving it, we can divide both sides by \(y\) to get help us utilize the chain rule to reverse the differentiation. However, dividing by \(y\) eliminates the valid solution \(y=0\), so keep that in mind.</p> \[\frac{y'}{y}=\lambda\] <p>But \(\frac{y'}{y}=\frac{d}{dt}\ln\left\lvert y \right\rvert\). So \(\frac{d}{dt}\ln\left\lvert y \right\rvert=\lambda\). That is,</p> \[\ln\left\lvert y \right\rvert=\lambda t+c\implies \left\lvert y \right\rvert=e^ce^{\lambda t}\] <p>Eliminating the absolute value would give us a \(\pm\), and since we also know \(y=0\) is a soultion, we can just say</p> \[\implies y=Ce^{\lambda t}\implies y\in\operatorname{span}(e^{\lambda t})\] <p>Remember, \(y\in\operatorname{span}(e^{\lambda t})\) just means that \(y\) is some linear combination of \(e^{\lambda t}\), which just means \(y=c_1e^{\lambda t}\).</p> <p>We have demonstrated that \(y'=\lambda y\implies y\in\operatorname{span}(e^{\lambda t})\), and I encourage you to verify that \(y'=\lambda y\impliedby y\in\operatorname{span}(e^{\lambda t})\). However, how do we <em>know</em> this provides us with <em>every</em> solution? No, get that Picard–Lindelöf s#!% out of here (it’s beautiful, yes, but not particularly intuitive). Suppose we have two solutions \(y_1,y_2\) with \(y_1\neq0\). Then</p> \[\frac{d}{dt}\left(\frac{y_2}{y_1}\right)=\frac{y_1y_2'-y_2y_1'}{y_1^2}\] \[=\frac{y_1(\lambda y_2)-y_2(\lambda y_1)}{y_1^2}=0\] <p>So \(\frac{y_2}{y_1}\) is just some constant \(C\), which implies that \(y_2=Cy_1\), which implies \(y_2\) is necessarily linearly dependent on \(y_1\). Therefore, we’ve shown that the solution space of \(y'=\lambda y\) (which is just \((D-\lambda)y=0\): the kernel of \((D-\lambda)\)) has dimension exactly 1, and it has a basis \(e^{\lambda t}\). In other words,</p> <p>\begin{equation}\label{kerda} \ker(D-\lambda)=\operatorname{span}(e^{\lambda t}) \end{equation}</p> <p>This demonstrates that <strong>every eigenvector of the differential operator is an exponential function \(Ce^{\lambda t}\)</strong>.</p> <p>Now, we have answered our first question:</p> <p><strong>Why is our guess for the solution \(e^{\lambda t}\)?</strong></p> <p><em>Because exponentials are the unique functions that can be eigenvectors of the differential operator</em>. Therefore, they will also be eigenvectors of the polynomial differential operator.</p> \[p(D)e^{\lambda t}=p(\lambda)e^{\lambda t}\] <p>So if \(p(\lambda)=0\), then \(e^{\lambda t}\) is a solution. That is why we consider</p> \[p(\lambda)=a_n\lambda^n+\ldots+a_1\lambda+a_0=0\] <p>Thus, because the kernel is a subspace closed under linear combinations, we can take a linear combination of exponentials \(e^{\lambda_1t},\ldots,e^{\lambda_nt}\), where \(\lambda_1,\ldots,\lambda_n\) are the roots of \(p(x)\), to say</p> \[y=c_1e^{\lambda_1t}+\ldots+c_ke^{\lambda_nt}\] <p>will be a solution to \(p(D)y=0\). Note: we do not say the <em>general</em> solution quite yet, as any repeated roots will make the set of these exponentials trivially linearly dependent.</p> <p>We remark that \eqref{kerda} equivalently tells us that if \(q(x)\) is a degree one polynomial, then \(\ker(q(D))\) has a basis \(\{e^{\lambda t}\}\) for \(\lambda\) such that \(q(\lambda)=0\), implying that the general solution to \(q(D)y=0\) is \(y=Ce^{\lambda t}\).</p> <p>We actually have enough now to prove that an \(n\)th order equation has homogeneous solution space of dimension exactly \(n\), but I want to take a detour to repeated roots first.</p> <h1 id="repeated-roots">Repeated Roots</h1> <p>i.e. why in the sweet heavenly cheese husk do we multiply by \(t\) of all things to get our other solutions?</p> <p>I brushed over this topic with a meme about reduction of order last time, but I actually have a good explanation this time.</p> <p>Let’s start with the simplest case. What’s the solution to the differential equation</p> \[D^ky=0\implies y^{(k)}=0?\] <p>This is one of the easiest differential equations, because we can just integrate \(n\) times to get</p> \[y=c_1+c_2t+\ldots+c_kt^{k-1}\] <p>Okay, easy enough. Now you may be thinking, “okay, when you put it like that, yeah repeated roots means repeated differentiation so that’s where the \(t\)’s come from <em>in this case</em>. But what about \((D-\lambda)^k\)?”</p> <h2 id="exponential-shift">Exponential Shift</h2> <p>Consider the derivative of \(e^{\lambda t}f(t)\).</p> \[D\left(e^{\lambda t}f(t)\right)=e^{\lambda t}(f'(t)+\lambda f(t))=e^{\lambda t}(D+\lambda)f(t)\] <p>If you’ve taken enough derivatives, you may have caught on to this little shortcut. Since exponentials just get scaled by derivatives, we can just sum up the derivatives of the function multiplying it and scale by the constant appropriately. But let me tell you, this generalizes incredibly. We call this property the <strong>exponential shift</strong>:</p> <p>\begin{equation} De^{\lambda t}=e^{\lambda t}(D+\lambda),\quad e^{\lambda t}D=(D-\lambda)e^{\lambda t} \end{equation}</p> <p>I encourage you to prove that linearity actually guarantees that</p> \[\begin{gather} p(D)e^{\lambda t}=e^{\lambda t}p(D+\lambda)\\ e^{\lambda t}p(D)=p(D-\lambda)e^{\lambda t} \end{gather}\] <p>And this is going to make our lives <em>so</em> much easier. Let’s go back to</p> \[(D-\lambda)y=0\] <p>If we multiply by \(e^{-\lambda t}\), then we can change that pesky \((D-\lambda)\) into just \(D\). That is,</p> \[e^{-\lambda t}(D-\lambda)y=(D-(-\lambda)-\lambda)e^{-\lambda t}y\] \[=D(e^{-\lambda t}y)=0\] <p>And if \(e^{-\lambda t}y\) is in the kernel of \(D\), then it’s just a constant. So \(e^{-\lambda t}y=C\implies y=Ce^{\lambda t}\).</p> <p>To summarize,</p> <p>\begin{equation} e^{-\lambda t}(D-\lambda)=De^{-\lambda t} \end{equation}</p> <p>If you look at what we did closely, you’ll notice this is basically just an <a href="../integratingfactor/" target="_blank">integrating factor</a>.</p> <p>The takeaway from this is: <strong>we can leverage the exponential shift to look at the kernel of just \(D\), which is equivalent to integration</strong>.</p> <h2 id="exponential-shift-into-overdrive">Exponential Shift Into Overdrive</h2> <p>Alright, so let’s answer the question. What happens when we have a repeated root in \(p(x)\) in general? Say that \((x-\lambda)^k\) divides \(p(x)\). That is, \(p(x)=q(x)(x-\lambda)^k\). Then if we multiply \(e^{-\lambda t}\) to \(p(D)y=0\), we get</p> \[e^{-\lambda t}q(D)(D-\lambda)^ky=q(D+\lambda)D^k(e^{-\lambda t}y)\] <p>If we let \(u=e^{-\lambda t}y\), then we get \(q(D+\lambda)D^ku=0\). Thus, any solution to \(D^ku=0\) will also be a solution to \(q(D+\lambda)D^ku=0\). And we know the solution to that is just \(c_1+c_2t+\ldots+c_kt^{k-1}\). Therefore,</p> \[u=e^{-\lambda t}y=c_1+c_2t+\ldots+c_kt^{k-1}\] \[y=e^{\lambda t}\left(c_1+c_2t+\ldots+c_kt^{k-1}\right)\] <p>is a solution to \(p(D)y=0\).</p> <p>And we have now answered our second question, <strong>“Why do we multiply by \(t\) when we have a repeated root of the characteristic polynomial?”</strong></p> <p><em>Because exponentials shift derivatives, and the kernel of repeated differentiation is a polynomial.</em></p> <p>What we have shown also essentially implies that every \(n\)th order differential equation of the form \(p(D)y=g(t)\) can be solved using \(n\) integrating factors. The first of which can be \(e^{-\lambda t}\), where \(\lambda\) is any root of \(p(x)\). After doing \(n\) integrations, we will be left with \(n\) arbitrary constants. This is consistent with the dimension of the kernel of an \(n\)th order linear equation’s solution space being dimension \(n\), but it does not answer why the functions on each arbitrary constant will necessarily be linearly independent. That is what we intend to prove in <a href="#second-order-two-independent-solutions">a later section</a>.</p> <p>But, this actually <em>does</em> imply something else very important: A particular solution to \(p(D)y=Be^{\lambda t}\) is guaranteed to exist, and can be obtained by factoring \(p(D)\), applying integrating factors, and integrating (taking all integration constants to be zero) until it is solved. However, we can actually find this particular solution directly using the exponential response formula, which is what we are going to do next.</p> <p>As a final remark for this section: for constant coefficients, reduction of order <em>is</em> just the exponential shift, but more roundabout. This is because you basically insert an exponential into the equation with \(y=ve^{\lambda t}\), which will cause things to shift. For example, if you’ve done reduction of order on \(y''-2ky'+k^2y=0\), \(y=e^{kt}v\), then you do end up with \(v''=0\). Which is exactly what we would expect:</p> \[(D-k)^2e^{kt}v=e^{kt}D^2v=0\implies v''=0\] <p>Except we didn’t have to do the product rule a bunch of times, plug in, and simplify.</p> <h2 id="exponential-response-formula">Exponential Response Formula</h2> <p>Alright, I’m going to prove and motivate the exponential response formula (ERF) in one line. Please try not to laugh too hard at how absurdly simple it is. By \eqref{divide} (yeah, remember <em>that</em> one?), if \(p(\lambda)\neq0\), then</p> \[p(D)e^{\lambda t}=p(\lambda)e^{\lambda t}\implies p(D)\left(\frac{Be^{\lambda t}}{p(\lambda)}\right)=Be^{\lambda t}\] <p>so \(\frac{Be^{\lambda t}}{p(\lambda)}\) is a particular solution. Okay, that’s all folks. Seeya next time!</p> <hr> <p>No, but really, it is that simple. We get \(\frac{Be^{\lambda t}}{p(\lambda)}\) as a preimage of \(Be^{\lambda t}\) because it’s an eigenvector, and we can just divide by the eigenvalue when it’s nonzero.</p> <p>We can use some of our techniques here to get the generalized exponential response formula (GERF) as well. However, it requires a result I don’t feel like proving:</p> <p><strong>\(p^{(k)}(\lambda)=0\) for \(0\leq k&lt;m\) and \(p^{(m)}(\lambda)\neq0\) if and only if \(\lambda\) is a root of \(p(x)\) with multiplicity exactly \(m\). And \(p(x)=q(x)(x-\lambda)^m\) where \(q(\lambda)=\frac{p^{(m)}(\lambda)}{m!}\neq0\)</strong></p> <p>Then for \(p(D)y=q(D)(D-\lambda)^my=Be^{\lambda t}\), we can use our good ol’ exponential shift with \(e^{-\lambda t}\).</p> \[q(D+\lambda)D^m(e^{-\lambda t}y)=B\] <p>Letting \(u=D^m(e^{-\lambda t}y)\), we get \(q(D+\lambda)u=B\), where we know that plugging in \(x=0\) into \(q(x+\lambda)\) will give us something nonzero. Hence, we can use our ERF to say a particular solution is \(u_p=\frac{B}{q(0+\lambda)}=\frac{Bm!}{p^{(m)}(\lambda)}\). That is,</p> \[D^m(e^{-\lambda t}y_p)=u_p=\frac{Bm!}{p^{(m)}(\lambda)}\] <p>Now, since we’re just looking for a single particular solution, we can just integrate \(m\) times and take all the constants to be \(0\). And since the \(m\)th integral of \(1\) is \(\frac{t^m}{m!}\), we basically just multiply by \(t^m\) and divide by \(m!\). Thus,</p> <p>\begin{equation}\label{gerf} y_p=\frac{Bt^me^{\lambda t}}{p^{(m)}(\lambda)} \end{equation}</p> <p>and there we go. If \(p^{(k)}(\lambda)=0\) for \(0\leq k&lt;m\) and \(p^{(m)}(\lambda)\neq0\), then \eqref{gerf} is a particular solution to \(p(D)y=Be^{\lambda t}\).</p> <h1 id="nth-order-n-independent-solutions">nth Order. n Independent Solutions</h1> <p>We can prove that \eqref{kerda}’s implication that a first order equation has kernel of dimension exactly one actually generalizes to \(n\)th order equations by induction. \eqref{kerda} is our base case, so let us assume that an \(n\)th order equation has a kernel of exactly degree \(n\). That is, if \(q(x)\) is degree \(n\), then \(\ker(q(D))\) has a basis \(y_1,\ldots,y_n\).</p> <p>Suppose \(p(x)\) is an \(n+1\)th degree polynomial. Then \(p(x)=(x-\lambda)q(x)\) for some \(q(x)\) that is degree \(n\) (this is guaranteed by the fundamental theorem of algebra, meaning \(\lambda\) might be complex). Hence,</p> \[p(D)y=0\implies (D-\lambda)q(D)y=0\] \[\implies q(D)y\in\ker(D-\lambda)\] <p>\eqref{kerda} then tells us that \(q(D)y=Ce^{\lambda t}\) for some \(C\). Let us first consider \(q(D)y=e^{\lambda t}\) (as we can multiply the particular solution by \(C\) to get a solution to the preceding equation). We know we can get some particular solution \(y_p\) to \(q(D)y=e^{\lambda t}\) using the GERF.</p> <p>That is, \(y_p\) is a preimage of \(e^{\lambda t}\) under \(q(D)\), so the general solution to \(q(D)y=e^{\lambda t}\) is \(y=c_1y_1+\ldots+c_ny_n+y_p\), where \(y_1,\ldots,y_n\) is a basis for \(\ker(q(D))\) (guaranteed to be size \(n\) by the inductive hypothesis) by the preimage theorem.</p> <p>But, if \(y_p\) is a preimage of \(e^{\lambda t}\) under \(q(D)\), then \(Cy_p\) is a preimage of \(Ce^{\lambda t}\) under \(q(D)\). Hence, the general solution to \(q(D)y=Ce^{\lambda t}\) is</p> \[y=c_1y_1+\ldots+c_ny_n+Cy_p\] <p>We claim that \(y\) is a solution to \(p(D)y=0\). If we take the image of \(y\) under \(q(D)\), we get \(Ce^{\lambda t}\) as we already defined \(y_1,\ldots,y_n\) to be a basis for its kernel and \(y_p\) to be a preimage of \(e^{\lambda t}\). That is,</p> \[q(D)\left(c_1y_1+\ldots+c_ny_n+Cy_p\right)=Ce^{\lambda t}\] <p>But if we then take the image of the result under \((D-\lambda)\), we will get zero by \eqref{kerda}. Hence, \(y\) is in the kernel of \((D-\lambda)\circ q(D)=(D-\lambda)q(D)=p(D)\).</p> <p>Now, \(y_p\) cannot be linearly dependent with \(y_1,\ldots,y_n\), because then it would be in the kernel of \(q(D)\) and thus could not be a preimage of \(e^{\lambda t}\neq0\) under \(q(D)\). Hence, \(\left\{y_1,\ldots,y_n,y_p\right\}\) form a set of \(n+1\) linearly independent vectors in \(\ker(p(D))\), making its dimension at least \(n+1\). We now need to show that there cannot be another linearly independent solution.</p> <p>Suppose that \(y_{n+2}\) is also a solution to \(p(D)y=0\) which is linearly independent with \(\{y_1,\ldots,y_n,y_p\}\). \(y_{n+2}\) can’t be in the kernel of \(q(D)\), because then it would be linearly dependent with \(y_1,\ldots,y_n\). So</p> \[q(D)y_{n+2}\neq0\implies q(D)y_{n+2}\in\ker(D-\lambda)\] <p>That is, \(q(D)y_{n+2}=c_{n+2}e^{\lambda t}\). But, like before, we know that \(c_{n+2}y_p\) will be a preimage of \(c_{n+2}e^{\lambda t}\) under \(q(D)\), so by the preimage theorem \(y_{n+2}=c_{n+2}y_p+y_h\) where \(y_h\in\ker(q(D))\). But, since \(y_h=d_1y_1+\ldots+d_ny_n\) for some constants \(d_i\), that means \(y_{n+2}=c_{n+2}y_p+d_1y_1+\ldots+d_ny_n\), contradicting that \(y_{n+2}\) is linearly independent from \(\{y_1,\ldots,y_n,y_p\}\). Therefore, the dimension of \(\ker(p(D))\) is exactly \(n+1\)!</p> <p>This answers our third question, <strong>“Why does an \(n\)th order equation have exactly \(n\) linearly independent homogeneous solutions?”</strong></p> <p>Because a homogeneous \(n\)th order equation is equivalent to a nonhomogeneous \((n-1)\)th order equation, for which the particular solution is necessarily linearly independent from the homogeneous solution in the dimension \(n-1\) kernel. And the particular solution for the reduced equation will then be a homogeneous solution for the \(n\)th order equation. And by the preimage theorem, any other solution will be linearly dependent on the general solution.</p> <p>As an unfortunate remark: this argument does not work for every type of differential equation. You do generally need more heavy duty techniques like reduction to a first order system of differential equations to prove this when the coefficients are not constant. Still, I like this very concrete proof for this very special case.</p> <h2 id="a-remark-on-undetermined-coefficients">A remark on undetermined coefficients</h2> <p>You can also utilize the exponential shift to more easily solve for more difficult particular solutions. If you have something like</p> \[p(D)y=q(t)e^{\alpha t}\] <p>where \(q(t)\) is some polynomial, then you can multiply by \(e^{-\alpha t}\) to make the RHS a simple polynomial. This will shift the equation to</p> \[p(D+\alpha)e^{-\alpha t}y=q(t)\] <p>In general, it’s slightly easier to solve this equation since your “guess” for a particular solution is just also a polynomial, removing the need to do product rules. Also, you can use <a href="../synthetictaylor/" target="_blank">synthetic division</a> to more easily calculate the coefficients of \(p(D+\alpha)\) without having to expand out the expressions and collect like terms. This is arguably a waste of time, and doesn’t cut down the computation time <em>too</em> much overall. I like to do it though.</p> <h2 id="complex-stuff">Complex Stuff</h2> <p>You may have noticed that I didn’t really specify what all the constants where in any of what I did. That’s because this general theory works for <em>all</em> polynomials, even complex ones. It’s only the very specific real polynomial case where you <em>can</em> always convert complex roots to sines and cosines. In most textbooks, they present this stuff in operator notation, but I’ll just speedrun through it for completion’s sake.</p> <p>If \(p(x)\) is a real polynomial (it has real coefficients, not complex ones), then \(p(D)\) is an operator that maps real functions to real functions. That is, if \(f(x)\) is a real valued function, then \(p(D)f(x)\) is also always real valued.</p> <p>Thus, if \(F(x)=u(x)+iv(x)\), then by linearity of linear transformations</p> \[p(D)F(x)=p(D)u(x)+ip(D)v(x)\] <p>So the real part of \(p(D)F(x)\) is \(p(D)\) applied to the real part of \(F(x)\), and similarly with the imaginary part.</p> <p>Hence, if \(p(D)F(x)=0\), then both the real and imaginary parts must be zero, so \(p(D)u(x)=p(D)v(x)=0\). That is, the real and imaginary parts of any complex element of the kernel are also individually in the kernel.</p> <p>It follows from <a href="../eulersformula/" target="_blank">Euler’s Formula</a> that if \(\alpha=a+bi\) is a root of \(p(x)\), then</p> \[e^{(a+bi)t}=e^{at}\left(\cos(bt)+i\sin(bt)\right)\] <p>will be a solution, so we can take the real and imaginary parts blah blah blah</p> \[y=e^{at}\left(c_1\cos(bt)+c_2\sin(bt)\right)\] <p>will be a solution.</p> <p>So, similar with repeated roots, the case of</p> \[y=(c_1+\ldots+c_kt^{k-1})e^{\alpha t}\] <p>just means two individual sets of solutions</p> \[\begin{align*} y_1=(c_1+\ldots+c_kt^{k-1})e^{at}\cos(bt)\\ y_2=(d_1+\ldots+d_kt^{k-1})e^{at}\sin(bt)\\ \end{align*}\] <p>It may seem like we’re doubling the number of solutions, but nah. This is because if \(p(x)\) is real valued, then any complex root will also have a corresponding complex conjugate root. And, since Euler’s formula basically just makes the conjugate flip the sign of the imaginary part, the two solutions taken from the conjugate solution will be linearly dependent on the two solutions obtained from the original complex root. That is, normally we have</p> \[y=(c_1+\ldots+c_kt^{k-1})e^{\alpha t}+(d_1+\ldots+d_kt^{k-1})e^{\overline\alpha t}\] <p>so we’re still left with \(2k\) solutions in the end.</p> <hr> <h2 id="final-thoughts">Final Thoughts</h2> <p>I love this perspective. The ideas of “exponentials would be an expected guess”, “to get the other solutions, multiply one solution by an arbitrary function \(v(t)\)”, or “just reduce the \(n\)th order equation down to a system of first order equations” would be mildly intuitive, but only in retrospect. As someone who questions a lot, and wants to know <em>why</em> something is true, the answers felt very contrived.</p> <p>But once we change from a differential equation to a linear operator, suddenly everything is a lot simpler (at least to me). The progression from first order to \(n\)th order is smooth and things just work out exactly the way you would expect them to.</p> <ul> <li>Exponentials are an expected guess because they are eigenvectors of the differential operator.</li> <li>To get the other solutions, we do an exponential shift, which effectively has us multiply by our first given solution.</li> <li>The dimension is \(n\) because each linear differential factor increases the dimension of the kernel by one.</li> </ul> <p>Granted, these justifications <em>only</em> work for constant coefficients. And, in general, reduction of order and reduction to a system of first order equations is necessary to generalize these ideas. But I greatly relish in the idea that we can make a much more elementary argument for this most special of cases that doesn’t end up relying on Picard–Lindelöf.</p> <p>But this is coming from someone who thinks a lot about these subjects, so perhaps it isn’t much easier for you. Especially if you don’t know any linear algebra (and if you got here without knowing linear algebra, uh… why? thank you for reading, but why?) I hope this was helpful, though.</p> <p>Also, this is a heavily condensed version of a chapter from a Linear Algebra + Differential Equations textbook I’m working on in my spare time (for which I have almost none now that I am in a PhD program). I hope you liked it, and maybe you’ll want to check out the textbook when it’s done (ETA: probably never). Alright, thanks for reading.</p> <p><a href="https://youtu.be/Tptx8boeGhE?si=1G60x2ZMJgUPC8Gr" target="_blank" rel="external nofollow noopener">hyperlink</a></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: July 30, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>